cc1에 의한 어셈블리 소스 파일로 컴파일

3가지 동작을 한다.
    1. front-end
    2. middle-end
    3. back-end

front-end
    언어 종속적인 부분을 처리하는 일이다.
    전체적으로 하는일은 소스코드가 올바르게 작성되었는지 분석하고
    중단부에 넘겨주기 위한 GIMPLE 트리 ( 소스코드를 트리 형태로 표현한 자료구조)를 생성하는 일이다.

middle-end
    GIMPLE트리를 이용해 아키텍처 비종속적인 최적화를 수행한다.
    최종적으로 후단부에서 사용하는 RTL( Register Transfer Language ) : 고급언어와 어셈블리 언어의 중간 형태
    를 생성한다.
    cc1에서 수행하는 최적화 중 많은 최적화가 중단부에서 이뤄진다. 
    결론 : 아키텍처 비종속적인 최적화!!

back-end
    아케텍처 종속적인 최적화가 수행된다. 그리고 최적화가 완료되면 목적 코드를 생성한다.
    여기서 목적 코드는 어셈블리 코드를 의미한다. 인스트럭션 스케줄링, 레지스터 할당과 같은 중요한 일이 수행된다.


front-end에서 하는일 심화
    C 소스 코드를 입력받아 문법상, 의미상의 오류를 파악하고, 트리 형태의 중간 표현 (IR : Intermediate Representation )인 GIMPLE 트리를 생성한다.
    1. 어휘 분석
    2. 구문 분석
    3. 의미 분석
    4. 중간 표현 생성

    어휘 분석 ( scanner ) 
        C 소스 코드를 의미가 있는 가장 최소 단위로 나누는 일이다.
        전처리가 된 like.i 소스 코드는 스캐너에 의해 읽혀지면서 소스코드를 문법적으로 의미가 있는 가장 최소 단위로 나눈다. 이런 문법적으로 의미 있는 가장 최소 단위의 문자열을 토큰이라 부르고, 종류는 아래와 같다
            # 지정어 ( if, while, for, do, switch, case 등 )
            # 연산 기호 ( +, -, *, /, %, <, >, = 등 )
            # 구분자 ( (, [, ,, ;, : 등 )
            # 명칭 ( main, print, var 등 )
            # 상수 ( 1203, 120.3, "I like you!\n" 등 )
        어휘분석은 해당 토큰들로 소스를 나누고 토큰을 하나씩 구문 분석을 담당하는 파서에게 넘긴다.

    구문 분석 ( parser )
        프로그램의 문법상 오류를 찾아내는 일을한다.
        like.c 파일에 문법적인 오류가 있었다면 이 단계에서 걸러진다. ( parser : 구문 분석기 )
        스캐너에게서 넘겨받은 토큰을 파스 트리를 만들면서 문법적 오류가 있는지 체크한다.

    의미 분석
        문법상의 오류는 없지만 의미상 오류가 있는것을 체크한다.
        선언되지 않은 변수를 사용했다거나, 함수를 사용하는 데 있어 인자 개수나 인자형이 불일치했다거나, 그리고 변수 사용에 있어 자료형이 불일치한 것 등이 의미 분석 단계에서 체크하는 것들이다.
        Scanner와 Parser에 의해 생성된 Symbol Table을 이용해 이런 일들을 수행한다.
        이 단계에서 C 소스파일 내에서 잘못 사용된 문법이나 오타, 잘못 사용된 함수, 정의되지 않은 변수의 사용 같은 오류들이 모두 걸러진다.

    중간 표현 생성
        거의 모든 컴파일러는 언어 종속적인 부분과 기계 종속적인 부분을 부리해 컴파일러를 모듈화하고 최적화를 쉽게 하기 위해 중간 표현을 사용한다.
        cc1은 내부적으로 두 가지 종류의 중간 표현을 사용하는데 하나는 GIMPLE트리이고, 다른 하나는 back-end에서 사용하는 RTL( Register Transfer Language )이다.

        GIMPLE 트리
            언어 독립적인 특성을 제공하기 위해 사용하는 트리 형태의 중간 표현
        RTL 트리
            기계 독립적인 특성을 제공하기 위해 사용하는 거의 어셈블리 수준의 중간 표현이다.

        GIMPLE 트리는 여러 프로그래밍 언어 소스를 공통된 언어 표현으로 바꾼 후 소스 코드를 트리 형태로 표현한 것이다.
        GIMPLE은 각언어의 AST(Abstract Syntax Tree) -> GENERIC tree -> GIMPLE tree 의 과정으로 생성된다.
        AST는 구문 분석( Parser )에 의해 생성된 파스트리를 간소화한 트리이다.


middle-end
    GIMPLE트리를 입력으로 받아 SSA( Static Single Assignment ) 형태로 변환한 후 SSA에 기초한 아키텍처 비종속적인 최적화를 수행하고, 최종적으로 cc1 후단부( back-end )에서 사용할 RTL을 생성하는 일이다.
    아키텍처 비종속적인라는 말의 의미는 아키텍처에 구애받지 않고 할 수 있는 최적화를 말한다.

    SSA 변환
        중간 표현의 한 가지 형태로서 변수에 값을 한 번만 할당하는 표현 형태를 의미한다. 예를 들어 다음과 같은 표현이 있다고 가정하자
        ex)
            i = 10
            j = i + 10
            k = j + 20
            j = i + k
            m = j + 5
        ex SSA )
            i_1 = 10
            j_2 = i_1 + 10
            k_3 = j_2 + 20
            j_4 = i_1 + K_3
            m_5 = j_4 + 5

        각 변수에는 한번만 값이 할당된다. 이렇게 중간 표현을 SSA 형태로 변경하는 이유는 SSA형태의 중간 표현이 사이드 이펙트가 없고, 데이터 흐름을 명시적으로 분명하게 표현할 수 있어 최적화를 구현하는데 용이하기 때문이다. 특히 몇몇 최적화는 반드시 SSA상에서 구현해야 하는것도 있다.
        때문에 gcc는 중단부 시작 부분에서 GIMPLE 트리를 SSA로 변경하고 이후 SSA 기반 최적화를 수행한다.
        SSA를 만들었다는 이야기는 그 부분부터는 중단부의 시작이라는 의미이다.

        @@@ cc1에서 수행하는 최적화는 2부분인데 1번째가 SSA 최적화 과정이고, 2번째가 후단부의 RTL 최적화이다.@@@
        
        SSA 기반 아키텍처 비종속적인 최적화
            3가지 부분으로 나눌수 있다. 지역 최적화, 전역 최적화, 루프 최적화라는 3가지로 나눈다.
            
            지역 최적화
                공통 부분식 제거, 연산 강도 경감, 상수 계산 등을 통해 최적화를 실현한다.
                예를 들면 곱하기 연산 중 쉬프트 연산으로 바꿀 수 있는 것은 바꾸고, var=5+3;을 var=8과 같이 미리 상수로 바꿀 수 있는 것은 바꾼다.    
            
            전역 최적화
                공통 부분식 제거, 사용되지 않는 코드를 제거

            루프 최적화
                루프 내에서 불변하는 코드를 루프 밖으로 빼버리거나, 합칠 수 있는 루프는 하나로 합치는 등의 일을 통해 최적화를 가능하게 한다.

    
    RTL 생성
        GCC에서 기계 독립적인 특성을 제공하기 위해 사용하는 중간 표현의 한 형태다. RTL은 여러 중간 표현 형태 동류 중 3-address 코드 형태이고 lisp 언어를 기반으로 하고 있어 lisp언어와 형태적으로 유사하다. 하지만 형태적으로 유사할 뿐이지 문법적으로는 많이 다르다.
        RTL은 후단부의 최적화 과정에서 사용되는 중간 표현인데, 레지스터 전송 언어 라는 이름에서 알 수 있듯이 레지스터 레벨의 연산과 오퍼랜드로 표현된다. 형식이 거의 어셈블리 언어와 유사하다. 하지만 특정 아키텍처에 종속적이지 않고 많은 아키텍처를 포용할 수 있게 설계되었다.

        /* 
            like.c 소스의 RTL 표현은 "gcc -o like like.c -da" 명령을 통해 볼 수 있다.
            like.c.00.expand 파일이 생성되는데, like.c.00.expand에 like.c의 RTL 표현을 볼 수 있다. 해당 파일이 존재하지 않는다면 like.c.xx.rtl파일을 보면 된다.
            RTL 아키텍처는 가상 아키텍처로서 레지스터 개수가 무한대이고, 여러 연산자와 여러 메모리 액세스 방법을 지원한다. 후에 실질 아키텍처로 매핑을 수행한다.

            위의 과정은 gcc포팅 혹은 디버깅할 때는 반드시 이해해야 한다.
            참고 문서 http://gcc.gnu.org/onlinedocs/gccint
        */

        gcc는 애초에 많은 아키텍처를 지원하는 컴파일러이다. 이런 기능이 가능한 이유는 RTL 표현이 많은 아키텍처의 특징을 표현할 수 있는 확장을 제공하기 때문이다.

    중단부 요약
        입력받은 GIMPLE -> SSA 생성 -> SSA 최적화 -> RTL 생성


back-end
    RTL을 입력받고, RTL 최적화를 진행하고, target 아케텍처 어셈블리를 생성하는 일을한다.
    
    RTL 최적화
        이전 까지 아키텍처 비종속적인 최적화만 수행하였지만 back-end에서는 아키텍처 비종속적인 최적화도 하지만 아키테거 종속적인 최적화도 함께 수행한다.
        아키텍처 종속적인 최적화가 핍홀( peephole ) 최적화의 일종인 기계 숙어( Machine idioms ) 변환인데, 여러 인스트럭션을 아키텍처에서 지원하는 하나의 인스트럭션으로 바꾸는 기법이다.
        예를 들어 DSP 계열 프로그래밍에서는 알고리즘 특성상 곱한 값을 다시 더하는 경우가 빈번하게 발생하는데, 이럴경우, mul 인스트럭션 다음에 add인스트럭션이 오는 pattern이 자주 반복된다. 목적 코드를 생성할 타켓 아키텍처에서 곱하고 더하는 것을 한 번에 할 수 있는 mac( Multiply and Accumulate )인스트럭션을 지원한다면 이런 두 개의 연산에 대해 모두 mac 인스트럭션 하나로 바꿀 수 있다. 하지만 이런 일은 해당 아키텍처에서 mac 연산을 지원해야만 가능하다. 이렇게 아키텍처의 특성을 타는 최적화를 아키텍처 종속적인 최적화라 한다.
        이러한 아키텍처 종속적인 최적화의 방법에는  레지스터 할당, 인스트럭션 선택, 메모리 접근, 연산 순서 조절과 같은 방법이 있다.

        레지스터 할당은 RTl을 실제 목적 코드로 변환하기 위해서 꼭 필요한, 중요한 일 중 하나다.
        가상 레지스터에 할당된 값들을 물리 레지스터로 할당하는 것은 어려운 일이다. 물리 레지스터에 모두 할당 할 수 있는 것은 할당하고, 그렇지 못한 것들은 메모리에 할당한다. 이렇게 메모리에 할당하는 것은 스필(spill)이라 한다.

    목적 코드 생성
        to be continued... 



        
